<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Reservas Inteligente - Parque Hidalgo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* [Estilos idénticos al código anterior] */
    </style>
</head>
<body>
    <div id="app">
        <!-- [Interfaz idéntica al código anterior] -->
    </div>
    
    <script>
    const { createApp, ref, computed, onMounted } = Vue;
    
    const SPORTS_DATA = { 
        /* [Datos de deportes idénticos al código anterior] */
    };
    
    // Constantes de tipos de error
    const ERROR_TYPES = {
        /* [Tipos de error idénticos al código anterior] */
    };

    createApp({
        setup() {
            // Lista de proxies CORS alternativos
            const PROXY_SERVICES = [
                url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
                url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
                url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
                url => `https://cors-anywhere.herokuapp.com/${url}`,
                url => `https://cors.bridged.cc/${url}`,
                url => url // Último recurso: intentar sin proxy
            ];
            
            // Contador de proxy actual
            let currentProxyIndex = 0;
            
            // Función para resolver problemas de CORS con rotación de proxies
            const withCorsProxy = (url) => {
                const proxyFn = PROXY_SERVICES[currentProxyIndex];
                currentProxyIndex = (currentProxyIndex + 1) % PROXY_SERVICES.length;
                return proxyFn(url);
            };

            // Variables de estado
            const activeTab = ref('config');
            const tabs = [
                { name: 'config', label: 'Configuración' }, 
                { name: 'execute', label: 'Ejecutar' }
            ];
            
            // [Resto del código de configuración idéntico al anterior]
            
            // Logger mejorado
            const logger = {
                /* [Logger idéntico al código anterior] */
            };
            
            // [Funciones restantes idénticas al código anterior]
            
            // Lógica principal del bot (reservas reales) - MEJORADA
            const runBotLogic = async () => {
                isBusy.value = true; 
                logs.value = [];
                errorLogs.value = [];
                status.value = { 
                    text: "Iniciando proceso de reserva...", 
                    color: "bg-blue-50 border-2 border-blue-200 text-blue-800",
                    icon: "fas fa-sync-alt animate-spin"
                };
                
                logger.step("--- INICIANDO BOT DE RESERVAS ---");
                logger.info("ℹ️ Intentando conectar a través de proxy CORS...");
                
                try {
                    // 1. Validar credenciales antes de enviar
                    logger.step("1. Validando credenciales...");
                    
                    if (!credentials.value.email || !credentials.value.password) {
                        throw new Error("Email o contraseña no configurados");
                    }
                    
                    if (!credentials.value.email.includes("@") || credentials.value.password.length < 6) {
                        throw new Error("Credenciales inválidas. Verifique el formato.");
                    }
                    
                    // 2. Iniciar sesión con manejo mejorado de errores
                    logger.step("2. Iniciando sesión en el sistema...");
                    
                    // Implementar timeout para evitar bloqueos
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);
                    
                    const authResponse = await fetch(withCorsProxy('https://reserva-parque.hidalgo.gob.mx/api/v1/auth/signin'), {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({
                            email: credentials.value.email,
                            password: credentials.value.password
                        }),
                        signal: controller.signal
                    }).finally(() => clearTimeout(timeoutId));
                    
                    // Manejo detallado de respuestas de autenticación
                    if (authResponse.status === 401) {
                        logger.error("Credenciales incorrectas", "Verifique su email y contraseña", 2, ERROR_TYPES.AUTH);
                        throw new Error("Credenciales incorrectas");
                    }
                    
                    if (authResponse.status === 400) {
                        const errorData = await authResponse.json();
                        logger.error("Solicitud inválida", errorData.message || "Formato de datos incorrecto", 2, ERROR_TYPES.AUTH);
                        throw new Error("Solicitud inválida");
                    }
                    
                    if (!authResponse.ok) {
                        const errorText = await authResponse.text();
                        logger.error(`Error en autenticación: ${authResponse.status}`, errorText, 2, ERROR_TYPES.AUTH);
                        throw new Error(`Error en autenticación: ${authResponse.status}`);
                    }
                    
                    const authData = await authResponse.json();
                    
                    if (!authData.token) {
                        logger.error("Token no recibido", authData, 2, ERROR_TYPES.AUTH);
                        throw new Error("No se recibió token de autenticación");
                    }
                    
                    const { token, user } = authData;
                    logger.info("✅ Autenticación exitosa. Token obtenido.");
                    
                    // 3. Obtener información de actividades
                    logger.step("3. Obteniendo información de actividades...");
                    const activitiesRes = await fetch(withCorsProxy('https://reserva-parque.hidalgo.gob.mx/api/v1/activity'), { 
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (!activitiesRes.ok) {
                        const errorText = await activitiesRes.text();
                        logger.error("Error al obtener actividades", `Status: ${activitiesRes.status} - ${errorText}`, 3, ERROR_TYPES.ACTIVITY);
                        throw new Error(`Error al obtener actividades: ${activitiesRes.status}`);
                    }
                    
                    const activities = await activitiesRes.json();
                    const activity = activities.find(a => a.name === config.value.activity_name);
                    if (!activity) {
                        logger.error(`Actividad no encontrada: ${config.value.activity_name}`, activities, 3, ERROR_TYPES.ACTIVITY);
                        throw new Error(`Actividad no encontrada: ${config.value.activity_name}`);
                    }
                    const space = activity.spaces.find(s => s.name === config.value.space_name);
                    if (!space) {
                        logger.error(`Espacio no encontrado: ${config.value.space_name}`, activity.spaces, 3, ERROR_TYPES.ACTIVITY);
                        throw new Error(`Espacio no encontrado: ${config.value.space_name}`);
                    }
                    logger.info(`✅ IDs obtenidos: Actividad ${activity._id}, Espacio ${space._id}`);
                    
                    // 4. Verificar disponibilidad
                    logger.step(`4. Verificando disponibilidad para ${config.value.date}...`);
                    const scheduleUrl = `https://reserva-parque.hidalgo.gob.mx/api/v1/reservation/schedules?space_id=${space._id}&date=${config.value.date}`;
                    const scheduleRes = await fetch(withCorsProxy(scheduleUrl), { 
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (!scheduleRes.ok) {
                        const errorText = await scheduleRes.text();
                        logger.error("Error al obtener horarios", `Status: ${scheduleRes.status} - ${errorText}`, 4, ERROR_TYPES.SCHEDULE);
                        throw new Error(`Error al obtener horarios: ${scheduleRes.status}`);
                    }
                    
                    const scheduleData = await scheduleRes.json();
                    const availableSchedules = scheduleData.available || [];
                    logger.info(`✅ Horarios disponibles: ${availableSchedules.length > 0 ? availableSchedules.join(', ') : 'Ninguno'}`);
                    
                    // 5. Crear reservas
                    let successCount = 0;
                    for (const hour of config.value.target_hours) {
                        logger.step(`5. Procesando reserva para ${hour}...`);
                        // Formato correcto: "HH:00-HH:00"
                        const nextHour = String(parseInt(hour.split(':')[0]) + 1).padStart(2, '0');
                        const timeSlot = `${hour}:00-${nextHour}:00`;
                        
                        if (availableSchedules.includes(timeSlot)) {
                            const payload = { 
                                solicitante_id: user._id, 
                                activity_id: activity._id, 
                                space_id: space._id, 
                                date: config.value.date, 
                                time_slot: timeSlot, 
                                number_players: config.value.number_players, 
                                responsive: true, 
                                equipment: false 
                            };
                            
                            if (config.value.activity_name !== 'Ajedrez') {
                                payload.teamName = currentSportConfig.value.team_name || "Equipo";
                            }
                            
                            logger.step(`Enviando solicitud de reserva para ${timeSlot}...`);
                            const res = await fetch(withCorsProxy('https://reserva-parque.hidalgo.gob.mx/api/v1/application'), { 
                                method: 'POST', 
                                headers: { 
                                    'Content-Type': 'application/json', 
                                    'Authorization': `Bearer ${token}` 
                                }, 
                                body: JSON.stringify(payload)
                            });
                            
                            if (!res.ok) {
                                const errorText = await res.text();
                                logger.error(`Error al reservar ${hour}`, `Status: ${res.status} - ${errorText}`, 5, ERROR_TYPES.RESERVATION);
                            } else {
                                const resData = await res.json();
                                logger.info(`✅ ¡Reserva confirmada para ${hour}! Folio: ${resData.folio}`);
                                successCount++;
                            }
                        } else { 
                            logger.warn(`⚠️ Horario ${hour} no disponible.`); 
                        }
                        
                        // Pequeña pausa entre solicitudes
                        await new Promise(r => setTimeout(r, 800));
                    }
                    
                    status.value = { 
                        text: `✅ Proceso completado: ${successCount} reserva(s) exitosa(s)`, 
                        color: "bg-green-50 border-2 border-green-200 text-green-800",
                        icon: "fas fa-check-circle"
                    };
                    
                    logger.step("--- EJECUCIÓN FINALIZADA CON ÉXITO ---");
                    
                } catch (e) {
                    // Manejo mejorado de diferentes tipos de errores
                    if (e.name === "AbortError") {
                        status.value = { 
                            text: "❌ Tiempo de espera agotado", 
                            color: "bg-red-50 border-2 border-red-200 text-red-800",
                            icon: "fas fa-exclamation-triangle"
                        };
                        logger.error("Tiempo de espera agotado", "El servidor no respondió a tiempo. Intente nuevamente.", 0, ERROR_TYPES.NETWORK);
                    } 
                    else if (e.name === "TypeError" && e.message.includes("Failed to fetch")) {
                        status.value = { 
                            text: "❌ Error de conexión", 
                            color: "bg-red-50 border-2 border-red-200 text-red-800",
                            icon: "fas fa-exclamation-triangle"
                        };
                        logger.error("Error de red", "No se pudo conectar al servidor. Verifique su conexión a Internet.", 0, ERROR_TYPES.NETWORK);
                    } 
                    else if (e.message.includes("Load failed")) {
                        status.value = { 
                            text: "❌ Error al cargar recurso", 
                            color: "bg-red-50 border-2 border-red-200 text-red-800",
                            icon: "fas fa-exclamation-triangle"
                        };
                        logger.error("Error al cargar recurso", "El servidor no pudo cargar el recurso solicitado. Verifique la URL.", 0, ERROR_TYPES.NETWORK);
                    }
                    else {
                        status.value = { 
                            text: `❌ Error: ${e.message}`, 
                            color: "bg-red-50 border-2 border-red-200 text-red-800",
                            icon: "fas fa-exclamation-triangle"
                        };
                        logger.error(`Error crítico: ${e.message}`, e, 0, ERROR_TYPES.SYSTEM);
                    }
                } finally { 
                    isBusy.value = false; 
                    scheduledExecution.value = null;
                    hasScheduledExecution.value = false;
                    localStorage.removeItem('scheduledExecution');
                    if (scheduledTimerId.value) {
                        clearInterval(scheduledTimerId.value);
                        scheduledTimerId.value = null;
                    }
                }
            };
            
            // [Resto de las funciones idénticas al código anterior]

            return { 
                /* [Todas las variables y funciones expuestas idénticas al código anterior] */
            };
        }
    }).mount('#app');
    </script>
</body>
</html>
